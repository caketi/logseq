---
title: tset
---

## 首先V8引擎，Node.js 和 基于Chrome内核的浏览器 都在使用。
假设我们有这样的代码，
1.当代码加载完毕后，js引擎会对代码扫描+编译
  注意：在此阶段，js引擎只会处理声明，赋值语句不会执行
  第一行 变量赋值，跳过
  第二行 是一个变量声明+赋值，js引擎会在全局执行环境的变量对象上添加b这个东西，然后初始化为undefined
  第三行 是一个函数声明，js引擎会吧函数的信息放在堆上，将v8这个名字指向堆上的信息。v8也被添加到全局执行环境的变量对象上
  第12行 调用v8，跳过
ok,创建的全局执行环境，大致如左图（具体不要纠结，大概就是这个样子）

可以看到，这个全局执行环境中有： 变量对象（b,v8)、作用域链条、this
2. 执行阶段
再次扫描，执行语句
第一行：为变量a赋值，先会在当前变量对象中查找变量 a，发现并没有找到属性 a。会沿着作用域链上的变量对象继续查找，直到查找到全局执行环境的变量对象，如果这时还没找到，就在全局执行环境的变量对象上添加上这个属性。 在这个例子中，由于当前的作用域链只包含全局执行环境的变量对象，而且 a 没有找到，所以它会在这个变量对象上添加 a 属性，并且将 a 的值初始化为 1。
第二行 同上，发现找到了b, b的值从undefined更新为2
第三行，跳过

3.编译
到了地12行，遇到v8调用，先把全局环境压入执行环境栈，创立一个新的v8执行栈
  第四行：一个声明， 把c加到v8的活动对象中，初始化为undefined
  第五航：把d加到v8的活动对象，初始化为undefined
  第六航：赋值，跳过
  第七行：函数声明，同v8()一样
  第十行： 调用， 跳过

前面将全局执行环境进行了压入栈的操作，现在作用域链条有了两个，一个v8, 一个global
4. v8执行环境--执行
第四行： 在v8变量对象中找到了c, 更新为10
第五行： 在v8变量对象中找到了d，更新为15
第六行： 在v8变量对象中未找到a, 顺藤摸瓜（沿着scopechain找下一个变量对象），在全局执行环境中找到了a,更新为3
第七行： 函数声明，跳过
5，v88执行环境--编译
第10行： v88调用，调用之前，js引擎把v8执行环境压入执行环境栈中，创建一个新的v88执行环境，开始v88执行环境下的编译
第8行：f声明， 把f加到v88执行环境的变量对象中去，初始化为undefined
6.v88执行环境--执行
f更新为5
。
v88执行结束后，v88执行环境出栈，v8执行完毕后，也出栈，全局执行环境出栈。执行完毕
